## 音乐数据获取工具实施计划（修订版）

### 模块结构

```
src/
├── music_source/          # 音乐源管理模块
│   ├── mod.rs
│   ├── source.rs          # MusicSource 枚举、SourceConfig 结构
│   └── source_manager.rs  # 源管理器
├── cache/                 # 缓存管理模块
│   ├── mod.rs
│   └── cache_manager.rs   # 缓存读写、序列化/反序列化
├── scanner/               # 扫描服务模块（多线程）
│   ├── mod.rs
│   └── music_scanner.rs   # 并行扫描、进度跟踪
└── lib.rs                 # 导出新增模块和 Tauri commands
```

### 实现步骤

1. **音乐源管理模块** (`music_source/mod.rs`, `source.rs`, `source_manager.rs`)

   * 定义 `MusicSource` 枚举：
     * `LocalFolder` - 本地文件夹（路径、递归深度）
     * `WebDisk` - 网盘源（URL、认证信息）

   * 定义 `SourceConfig` 结构：源ID、类型、路径/URL、启用状态、扫描选项

   * 定义 `SourceManager`：管理源列表、添加/删除/启用/禁用源

2. **缓存管理模块** (`cache/mod.rs`, `cache_manager.rs`)

   * 实现 `get_cache_dir()` 函数（使用 `dirs::cache_dir()`）

   * 实现 `CacheManager`：缓存扫描结果（JSON 格式）

   * 缓存键设计：基于源路径 + 文件列表哈希

3. **音乐扫描服务 - 多线程优化** (`scanner/mod.rs`, `music_scanner.rs`)

   * 使用 `rayon` 或 `std::thread::scope` 实现线程池

   * **本地文件夹扫描**：使用 `std::fs::ReadDir` 配合并行迭代

   * **网盘源扫描**：通过 webdev 协议获取文件列表，然后并行下载和读取元数据

   * 集成现有 `audio_metadata` 模块的 `read_metadata` 函数

   * 支持进度回调（通过 Tauri event）和取消操作

4. **启动加载逻辑**

   * 启动时检查所有已启用源的缓存

   * 如果缓存存在则加载，直到用户触发刷新扫描

5. **Tauri Commands 集成**

   * `add_local_source(path, recursive)` - 添加本地音乐源

   * `add_web_source(url, auth)` - 添加网盘源

   * `remove_source(id)` - 移除音乐源

   * `scan_sources()` - 并行扫描所有源（不阻塞主线程）

   * `get_cached_library()` - 获取缓存的音乐库

   * `refresh_source(id)` - 刷新单个源

### 多线程扫描设计

```
主线程 (Tauri)
    │
    ├── Spawn thread pool (rayon/scoped threads)
    │       │
    │       ├── Task 1: Scan folder A ──→ Parse metadata
    │       ├── Task 2: Scan folder B ──→ Parse metadata
    │       └── Task N: Web disk API   ──→ Download & parse
    │       │
    └── Emit progress events ←─────── Progress callback
```

### 数据流

```
启动 → 检查缓存 → 如果有缓存则加载缓存
                    ↓ (用户触发扫描或添加新源)
              多线程扫描 → 读取元数据 → 更新缓存 → 返回结果
```

### 依赖

* 添加 `dirs` crate 用于获取缓存目录

* 添加 `rayon` crate 用于数据并行扫描

* 使用 `tokio`（如果网盘源需要异步 HTTP 请求）

* 使用现有 `serde_json` 进行缓存序列化

### 文件变更

* 新增 6 个文件：`music_source/mod.rs`, `music_source/source.rs`, `music_source/source_manager.rs`, `cache/mod.rs`, `cache/cache_manager.rs`, `scanner/mod.rs`, `scanner/music_scanner.rs`

* 修改 1 个文件：`src/lib.rs`（添加模块导出和 Tauri commands）

* 修改 1 个文件：`Cargo.toml`（添加 `dirs`, `rayon`, `tokio` 依赖）

